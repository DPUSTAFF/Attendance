# Tackle Noise with Error Correction

# Tackle Noise with Error Correction

# --- Import Required Libraries ---
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile
from qiskit_aer import AerSimulator
from qiskit_aer.noise import NoiseModel, depolarizing_error
from qiskit.visualization import plot_histogram
import matplotlib.pyplot as plt
import numpy as np


# Step 1: Create 3-qubit + 3-classical-bit circuit
qc = QuantumCircuit(3, 3)

# Step 2: Encode logical |1> as |111>
qc.x(0)
qc.cx(0, 1)
qc.cx(0, 2)

# Step 3: Introduce a bit-flip error (simulate noise)
qc.x(1)  

# Step 4: Decode (majority vote style correction)
qc.cx(0, 1)
qc.cx(0, 2)
qc.ccx(1, 2, 0)

# Step 5: Measure
qc.measure([0, 1, 2], [0, 1, 2])

print(qc.draw(output='text'))

# --- Step 6: Run Simulation with Noise ---
backend = AerSimulator()
compiled_circuit = transpile(circuit, backend)
job = backend.run(compiled_circuit, shots=1024, noise_model=noise)
output = job.result().get_counts(circuit)

# --- Step 7: Apply Simple Error Mitigation ---
mitigated_count = {key: output[key] * (1 - 0.2) for key in output}

# --- Step 8: Plot Results ---
x = np.arange(len(output))
width = 0.35

plt.bar(x - width/2, list(output.values()), width, label='Noisy Output')
plt.bar(x + width/2, list(mitigated_count.values()), width, label='Mitigated Output')

plt.xticks(x, list(output.keys()))
plt.xlabel("Measurement Outcomes")
plt.ylabel("Counts")
plt.title("Quantum Error Mitigation - Bit Flip Noise")
plt.legend()
plt.show()

# Step 9: Display measurement results
print("\nMeasurement outcomes:")
print(counts)
